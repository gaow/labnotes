#!/usr/bin/env python
import argparse, sys, os
from subprocess import call
from gwlog2tex import LogToTex
from minted import minted
def getCompilerArguments(parser):
	parser.add_argument('filename',
                        metavar = 'FN',
                        nargs = '+',
                        help='''Name of the input log file(s).
                        This will create a new file [FN.pdf] under the current directory
                        (or [FN1-FN2-...-FNX.pdf] if there are multiple files).''')
	parser.add_argument('-a', '--author',
                        action='store',
                        default = '',
                        help='''Author's name of the document''')
	parser.add_argument('-t', '--title',
                        action='store',
                        default = '',
                        help='''Title of document''')
	parser.add_argument('-c', '--notoc',
                        action='store_true',
                        default = '',
                        help='''Do not generate table of contents''')
	parser.add_argument('-r', '--rmcache',
                        action='store_true',
                        default = '',
                        help='''Remove cache files''')

def pdflatex(fname, text, rmcache):
    with open(fname + '.tex', 'w') as f:
        f.writelines(text)
    m = minted()
    m.put()
    call(["pdflatex", "-shell-escape", "-halt-on-error", "-file-line-error", fname + '.tex'])
    #if (tc.returncode):
    #    sys.exit("ERROR: pdflatex returned non-zero exit code. Please manually compile {0}.tex to troubleshoot".format(fname))
    call(["pdflatex", "-shell-escape", "-halt-on-error", "-file-line-error", fname + '.tex'])
    torm = ['aux', 'log', 'out', 'toc']
    if rmcache:
        torm.append('tex')
        call(['rm', '-rf', '.minted_cache'])
    else:
        call(['mv', fname + '.tex', '.' + fname + '.tex'])
    for ext in torm:
        try:
            call(['rm', '-f', fname + '.' + ext])
        except:
            pass
    m.delete()
    return

def lite(args):
    fname = '-'.join([os.path.splitext(name)[0] for name in args.filename]) + '.' + 'lite'
    tex = LogToTex(args.title, args.author, args.notoc, args.filename)
    pdflatex(fname, tex.get(1), args.rmcache)
    return

def full(args):
    fname = '-'.join([os.path.splitext(name)[0] for name in args.filename]) + '.' + 'full'
    tex = LogToTex(args.title, args.author, args.notoc, args.filename)
    pdflatex(fname, tex.get(0), args.rmcache)
    return

if __name__ == '__main__':
	master_parser = argparse.ArgumentParser(
        description = '''Compile formatted log notes into pdf file''',
        prog = 'gw_log',
        fromfile_prefix_chars = '@',
        epilog = '''gw_log, motivated by documenting the workflow for the ESP6900 data analysis.
	Contact: Gao Wang <gaow@bcm.edu>''')
	master_parser.add_argument('--version', action='version', version='%(prog)s 1.0alpha')
	subparsers = master_parser.add_subparsers()
	# compile a project log file
	parser = subparsers.add_parser('lite', help='Generate main text from log file(s)')
	getCompilerArguments(parser)
	parser.set_defaults(func=lite)
	# compile a project log file
	parser = subparsers.add_parser('full', help='Generate main text + comments from log file(s)')
	getCompilerArguments(parser)
	parser.set_defaults(func=full)
	# getting args
	args = master_parser.parse_args()
	# calling the associated functions
	args.func(args)
